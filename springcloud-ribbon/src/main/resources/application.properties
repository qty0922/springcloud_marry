server.port=8083
#服务注册中心的配置内容，指定服务注册中心的位置
eureka.client.service-url.defaultZone=http://qty:qty@127.0.0.1:8080/eureka/
#需要指明spring.application.name,这个很重要，这在以后的服务与服务之间相互调用一般都是根据这个name
spring.application.name=springcloud-ribbon
#设置ribbon读取超时时间
ribbon.ReadTimeout=6000
#设置ribbon连接超时时间
ribbon.ConnectTimeout=6000


#ribbon.eager-load.enabled：开启 Ribbon 的饥饿加载模式。
#ribbon.eager-load.clients：指定需要饥饿加载的服务名，也就是你需要调用的服务，若有多个则用逗号隔开。
#ribbon.eager-load.enabled=true
#ribbon.eager-load.clients=springcloud-ribbon


#――――――――――――――――――――――――――――――――――――――――ribbon常用配置信息――――――――――――――――――――――――――――――――――

#1、禁用 Eureka
#ribbon.eureka.enabled=false

#2、禁用 Eureka 后手动配置服务地址
# 前缀就是服务名称，配置完之后就可以和之前一样使用服务名称来调用接口
#ribbon-config-demo.ribbon.listOfServers=localhost:8081,localhost:8083

#3、设置超时时间
# 请求连接的超时时间
#ribbon.ConnectTimeout=2000
# 请求处理的超时时间
#ribbon.ReadTimeout=5000

#    或者

#也可以为每个Ribbon客户端设置不同的超时时间, 通过服务名称进行指定：
#ribbon-config-demo.ribbon.ConnectTimeout=2000
#ribbon-config-demo.ribbon.ReadTimeout=5000


#4、并发参数
# 最大连接数
#ribbon.MaxTotalConnections=500
# 每个host最大连接数
#ribbon.MaxConnectionsPerHost=500

#――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

#―――――――――――――――――――――――――――――――――――――――――重试机制――――――――――――――――――――――――――――――――――――――――――

#重试机制就是当 Ribbon 发现请求的服务不可到达时，重新请求另外的服务

#1、RetryRule 重试：只需要指定某个服务的负载策略为重试策略即可
#ribbon-config-demo.ribbon.NFLoadBalancerRuleClassName=com.netflix.loadbalancer.RetryRule

#2、Spring Retry 重试
#在 pom.xml 中添加 Spring Retry 的依赖，代码如下所示。
#<dependency>
#<groupId>org.springframework.retry</groupId>
#<artifactId>spring-retry</artifactId>
#</dependency>

#配置重试次数等信息：
# 对当前实例的重试次数
#ribbon.maxAutoRetries=1
# 切换实例的重试次数
#ribbon.maxAutoRetriesNextServer=3
# 对所有操作请求都进行重试
#ribbon.okToRetryOnAllOperations=true
# 对Http响应码进行重试
#ribbon.retryableStatusCodes=500,404,502

#――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
